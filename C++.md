<h1>C++</h1>
<details><summary>1.什么是<b>段错误</b>?</summary>
  <li>段错误就是程序访问受保护或者不存在的内存的时候引发的错误
  <li>引发段错误原因有：访问受保护的内存、访问不存在的内存、访问只读的内存、访问空指针的值、堆栈溢出、内存溢出等
</details>
<details><summary>2.<b>extern</b>关键字有什么用?</summary>
  主要有两个作用
  <li>第一个作用是放在变量名和函数面前，表示声明这个变量或者是函数，而这个变量或者函数是在其它文件中定义的，所以这里只有声明并拿来引用，而非定义，所以也不分配空间
  <li>第二个作用是和C双引号字符连用，这样让后面的函数在C++程序编译时还是按C编译的规则，就是不改变函数的名字，而如果不加的话，C++编译时会改变函数的名字，通过将函数的名字和参数联合生成一个新的函数名，C++之所以编译会改变函数名字，是为了适用于函数多态服务。而如果在C++文件中使用C语言的头文件，可能因为没有加extern "C"而找不到这个函数。所以extern "C"也常常用于C语言的头文件中。
</details>
<details><summary>3.<b>static</b>关键字有什么用?</summary>
  static用于声明用于内部连接的变量或函数，和extern相反。
  <li>首先static可以用在局部变量的声明前，这样的话，这个局部变量将是存储在程序的静态存储区，而非内存栈中。这样一来，这个局部变量的生命周期就会跟整个程序一样，在main函数运行前就会创建，在程序退出时才会销毁。所以当包含局部变量的函数再次调用的时候，这个局部变量依然是上一次退出时的值，也并不会重新创建。
  <li>第二个是static可以用于全局变量和函数前，这两个作用类似，就是让这个全局变量和函数只能在这个文件内使用，外部文件无法调用。这个通常用在工程项目中防止多个文件内用重名的全局变量和函数，而作用不同发生混淆
  <li>第三个的话，static可以用在类的成员变量前，这类似于用在局部变量前，这样一来，成员变量存储在静态存储区，然后不依赖与类的对象而存在，也就是创建类的对象时，并不会再分配这个变量空间，因为都是共享这个静态存储区的这个成员变量，这样也能提高速度和优化空间。
  <li>最后还有，static可以用在成员函数前，这样的话，这个函数没有指向类的this指针，所以也无法访问类的其它成员，除了类内的其它静态成员
  <li>另外static声明的变量会默认初始化为0
 </details>
<details><summary>4.<b>volatile</b>[ˈvɒlətaɪl]关键字有什么事用？</summary>
  <li>volatile用于声明一个易变的变量，在定义前加volatile，就让这个程序每次使用这个变量的时候都要从内存也就是变量的地址空间中读取变量，而不能到CPU寄存器里读取
  <li>volatile经常用于多线程中，使得一个线程对该变量的改变，等同于能马上让所有其它线程获悉这个改变，保持数据一致性。
</details>
<details><summary>5.<b>const</b>关键字有什么用？(定义 指针 成员 define 传入 内存 转换)</summary>
  <li>const关键字用于声明常量，常量就是不发生改变的量，所以const声明变量时需要初始化。
  <li>const可以和指针连用，有两种用法：第一种是常量指针，格式有两种，拿int举例的话是const int*和int const*，这两者是等价的,常量指针指的就是这个指针指向的变量是一个常量，但是这个指针指向谁是可以变的，只需要指向的对象是一个常量就行；第二种是指针常量,拿int举例的话就是int *const ,指针常量的意思是这个指针就是一个常量，也就是只能指向初始化给定的地址，不能改变，但是可以通过改变这个地址上存储的数来改变访问该指针时获得的数据。
  <li>const在设计初是用于完美替换#define 宏定义的常量的，这两者的区别就是，一个是用#define定义的常量 不会进行类型安全检查，也没有限定是什么类型，就只是替换；但是const会限定类型，进行安全检查，从安全性上更安全。另一个是存储方式也不同，#define定义的常量不分配空间，但const修饰的常量分配内存空间。然后还有是#define如果定义的常量是一个运算式子，那么每次调用define都会运算一遍，而const会先算出值，之后每次调用就只使用初始化的值。
  <li>const还有在类中用于修饰成员变量和成员函数，修饰成员变量的话，那么这个成员变量就是常量，需要在初始化列表初始化；修饰成员函数的话，其实是修饰这个成员函数的this指针，也是说这个成员函数无法对这个类中的其它变量进行修改，所以const也不能用于类的构造函数，当然也不能用于用static修饰的成员函数，因为static修饰的成员函数没有了this指针。不然如果就是想要在这种情况下成员函数内修改成员变量，可以在那个成员变量前加mutable关键字。然后const用于修饰类的对象的话，那么这个对象只能使用类中用const修饰的成员函数,然后也不能改变这个类的成员变量。
 <li>const还常用语修饰函数的传入参数，那么这个应用是为了保证传入参数在函数期间不会被修改。
<li>还有就是在C++中用const修饰的全局变量的连接方式默认为内部连接，就是只有本文件能使用，其它文件不行。不过可以通过在前面再加extern来将连接方式变为外部连接。不过在C中const修饰的全局变量还是外部连接的。
<li>另外C和C++中使用const的不同还在于，C++中用const修饰的变量默认是不分配内存空间的，是保存在符号表中的，只用使用到取地址的时候或者前面加extern等操作会再分配内存空间；而C中const修饰的变量一定要分配内存空间。
 <li>还有一点就是const和非const的转化也是有限制的，非const变量可以给const变量赋值，但反过来不行。对于这点的理解的话，其实类似于数据库中的排它锁和共享锁。const相当于给变量加了共享锁，就是只读数据，而非const就是可读也可写的数据。那么从权限的角度讲，非const给const赋值，取消了可写性，权限降低显然是安全的，但是提高权限则不安全，所以反过来就不行。
</details>
<details><summary>6.<b>new</b>和<b>malloc</b>的区别</summary>
<li>new和malloc都是用于给指针分配内存空间的方式。但new是C++的关键字，而malloc是C的库函数方法，通常new和delete配套使用，malloc和free配套使用，防止内存泄露。
<li>首先是他们申请的内存空间的所在位置，new申请的内存空间在自由存储区，而malloc申请的内存空间在堆上，两个都是动态分配内存。自由存储区包含堆，自由存储区就是C++根据new申请的内存空间定义的名称，自由存储区具体在哪由operator new函数的实现方式决定，如果是由malloc函数实现的，就是在堆上，其它实现方式的话还可以在静态存储区上，甚至不分配内存。
<li>所以这里也提到了new可以调用malloc，就是new可以通过malloc来实现，但是反过来就不行。
<li>其次，使用new具有类型安全性，因为new需要指定指针的类型，因为new需要指定具体是哪个类，但malloc没有类型安全性，因为它返回的是一个void*类型的指针，这个指针就是用于强制转换成其它类型的指针，所以malloc通常是使用时进行强制类型转换，所以没有类型安全性。
<li>然后关于内存分配失败时的反应也不同，new内存分配失败，也就是内存不够时，会调用一个函数，这个函数是new_handler默认是错误处理函数，它会抛出一个异常，但是用户可以通过set_new_handler函数来设置内存分配失败时做出的处理。但malloc内存分配失败时不会抛出异常，而是返回NULL，继续运行。
<li>另外关于分配内存，new在使用时不需要制定分配的内存大小，程序会根据类型自己计算，同时也支持通过中括号[]来进行数组版本的内存分配；但是malloc需要显式地给出分配的内存空间大小，如果是数组的话，就需要乘上数组大小。
<li>new和malloc还有个关键区别就是，new在使用时会调用这个类的构造函数，之后如果在使用delete回收时delete会调用类的析构函数；而malloc和free不会调用。
<li>还有new支持函数重载，但是malloc不支持。
<li>不过使用malloc也是有优点的，可以使用配套使用realloc进行扩充内存或者重新分配内存，但是new没有类似的配套方法。
<li>之前提到内存泄露，内存泄露对于new和malloc都能检测出来，但是new能具体指出是文件的那一行，但是malloc不行
  </details>
<hr>



<h2>算法题笔记</h2>
<details><summary>
  1.声明一个结构体指针</summary>
<pre>
    (i)node *Begin=(node *)malloc(sizeof(node)),*another=(node *)malloc(sizeof(node));</br>
    (ii)node *Begin=new node(3),*another=new node(5);
</pre>
</details>
<details><summary>2.设计一个二叉树类</summary>
<pre>
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
</pre>
</details>
