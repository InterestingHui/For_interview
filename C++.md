<h1>C++编程</h1>
<details><summary>1.什么是<b>段错误</b>?</summary>
  <li>段错误就是程序访问受保护或者不存在的内存的时候引发的错误
  <li>引发段错误原因有：访问受保护的内存、访问不存在的内存、访问只读的内存、访问空指针的值、堆栈溢出、内存溢出等
</details>
<details><summary>2.<b>extern</b>关键字有什么用?</summary>
  主要有两个作用
  <li>第一个作用是放在变量名和函数面前，表示声明这个变量或者是函数，而这个变量或者函数是在其它文件中定义的，所以这里只有声明并拿来引用，而非定义，所以也不分配空间
  <li>第二个作用是和C双引号字符连用，这样让后面的函数在C++程序编译时还是按C编译的规则，就是不改变函数的名字，而如果不加的话，C++编译时会改变函数的名字，通过将函数的名字和参数联合生成一个新的函数名，C++之所以编译会改变函数名字，是为了适用于函数多态服务。而如果在C++文件中使用C语言的头文件，可能因为没有加extern "C"而找不到这个函数。所以extern "C"也常常用于C语言的头文件中。
</details>
<details><summary>3.<b>static</b>关键字有什么用?</summary>
  static用于声明用于内部连接的变量或函数，和extern相反。
  <li>首先static可以用在局部变量的声明前，这样的话，这个局部变量将是存储在程序的静态存储区，而非内存栈中。这样一来，这个局部变量的生命周期就会跟整个程序一样，在main函数运行前就会创建，在程序退出时才会销毁。所以当包含局部变量的函数再次调用的时候，这个局部变量依然是上一次退出时的值，也并不会重新创建。
  <li>第二个是static可以用于全局变量和函数前，这两个作用类似，就是让这个全局变量和函数只能在这个文件内使用，外部文件无法调用。这个通常用在工程项目中防止多个文件内用重名的全局变量和函数，而作用不同发生混淆
  <li>第三个的话，static可以用在类的成员变量前，这类似于用在局部变量前，这样一来，成员变量存储在静态存储区，然后不依赖与类的对象而存在，也就是创建类的对象时，并不会再分配这个变量空间，因为都是共享这个静态存储区的这个成员变量，这样也能提高速度和优化空间。
  <li>最后还有，static可以用在成员函数前，这样的话，这个函数没有指向类的this指针，所以也无法访问类的其它成员，除了类内的其它静态成员。所以static并不能修饰类中的构造函数和虚函数，因为两者都需要用到this指针。
  <li>另外static声明的变量会默认初始化为0
 </details>
<details><summary>4.<b>volatile</b>[ˈvɒlətaɪl]关键字有什么事用？</summary>
  <li>volatile用于声明一个易变的变量，在定义前加volatile，就让这个程序每次使用这个变量的时候都要从内存也就是变量的地址空间中读取变量，而不能到CPU寄存器里读取
  <li>volatile经常用于多线程中，使得一个线程对该变量的改变，等同于能马上让所有其它线程获悉这个改变，保持数据一致性。
</details>
<details><summary>5.<b>const</b>关键字有什么用？(定义 指针 成员 define 传入 连接 内存 转换)</summary>
  <li>const关键字用于声明常量，常量就是不发生改变的量，所以const声明变量时需要初始化。
  <li>const可以和指针连用，有两种用法：第一种是常量指针，格式有两种，拿int举例的话是const int*和int const*，这两者是等价的,常量指针指的就是这个指针指向的变量是一个常量，但是这个指针指向谁是可以变的，只需要指向的对象是一个常量就行；第二种是指针常量,拿int举例的话就是int *const ,指针常量的意思是这个指针就是一个常量，也就是只能指向初始化给定的地址，不能改变，但是可以通过改变这个地址上存储的数来改变访问该指针时获得的数据。
  <li>const在设计初是用于完美替换#define 宏定义的常量的，这两者的区别就是，一个是用#define定义的常量 不会进行类型安全检查，也没有限定是什么类型，就只是替换；但是const会限定类型，进行安全检查，从安全性上更安全。另一个是存储方式也不同，#define定义的常量不分配空间，但const修饰的常量分配内存空间。然后还有是#define如果定义的常量是一个运算式子，那么每次调用define都会运算一遍，而const会先算出值，之后每次调用就只使用初始化的值。
  <li>const还有在类中用于修饰成员变量和成员函数，修饰成员变量的话，那么这个成员变量就是常量，需要在初始化列表初始化；修饰成员函数的话，其实是修饰这个成员函数的this指针，也是说这个成员函数无法对这个类中的其它变量进行修改，所以const也不能用于类的构造函数，当然也不能用于用static修饰的成员函数，因为static修饰的成员函数没有了this指针。不然如果就是想要在这种情况下成员函数内修改成员变量，可以在那个成员变量前加mutable关键字。然后const用于修饰类的对象的话，那么这个对象只能使用类中用const修饰的成员函数,然后也不能改变这个类的成员变量。
 <li>const还常用语修饰函数的传入参数，那么这个应用是为了保证传入参数在函数期间不会被修改。
<li>还有就是在C++中用const修饰的全局变量的连接方式默认为内部连接，就是只有本文件能使用，其它文件不行。不过可以通过在前面再加extern来将连接方式变为外部连接。不过在C中const修饰的全局变量还是外部连接的。
<li>另外C和C++中使用const的不同还在于，C++中用const修饰的变量默认是不分配内存空间的，是保存在符号表中的，只用使用到取地址的时候或者前面加extern等操作会再分配内存空间；而C中const修饰的变量一定要分配内存空间。
 <li>还有一点就是const和非const的转换也是有限制的，非const变量可以给const变量赋值，但反过来不行。对于这点的理解的话，其实类似于数据库中的排它锁和共享锁。const相当于给变量加了共享锁，就是只读数据，而非const就是可读也可写的数据。那么从权限的角度讲，非const给const赋值，取消了可写性，权限降低显然是安全的，但是提高权限则不安全，所以反过来就不行。
</details>
<details><summary>6.<b>new</b>和<b>malloc</b>的区别(来源 位置 调用 类型安全 分配失败 分配大小 构造函数 重载 扩存 内存泄露)</summary>
<li>new和malloc都是用于给指针分配内存空间的方式。但new是C++的关键字，而malloc是C的库函数方法，通常new和delete配套使用，malloc和free配套使用，防止内存泄露。
<li>首先是他们申请的内存空间的所在位置，new申请的内存空间在自由存储区，而malloc申请的内存空间在堆上，两个都是动态分配内存。自由存储区包含堆，自由存储区就是C++根据new申请的内存空间定义的名称，自由存储区具体在哪由operator new函数的实现方式决定，如果是由malloc函数实现的，就是在堆上，其它实现方式的话还可以在静态存储区上，甚至不分配内存。
<li>所以这里也提到了new可以调用malloc，就是new可以通过malloc来实现，但是反过来就不行。
<li>其次，使用new具有类型安全性，因为new需要指定指针的类型，因为new需要指定具体是哪个类，但malloc没有类型安全性，因为它返回的是一个void*类型的指针，这个指针就是用于强制转换成其它类型的指针，所以malloc通常是使用时进行强制类型转换，所以没有类型安全性。
<li>然后关于内存分配失败时的反应也不同，new内存分配失败，也就是内存不够时，会调用一个函数，这个函数是new_handler默认是错误处理函数，它会抛出一个异常，但是用户可以通过set_new_handler函数来设置内存分配失败时做出的处理。但malloc内存分配失败时不会抛出异常，而是返回NULL，继续运行。
<li>另外关于分配内存，new在使用时不需要制定分配的内存大小，程序会根据类型自己计算，同时也支持通过中括号[]来进行数组版本的内存分配；但是malloc需要显式地给出分配的内存空间大小，如果是数组的话，就需要乘上数组大小。
<li>new和malloc还有个关键区别就是，new在使用时会调用这个类的构造函数，之后如果在使用delete回收时delete会调用类的析构函数；而malloc和free不会调用。
<li>还有new支持函数重载，但是malloc不支持。
<li>不过使用malloc也是有优点的，可以使用配套使用realloc进行扩充内存或者重新分配内存，但是new没有类似的配套方法。
<li>之前提到内存泄露，内存泄露对于new和malloc都能检测出来，但是new能具体指出是文件的那一行，但是malloc不行
  </details>
 <details><summary>7.构造、析构函数能抛出异常吗？</summary>
  <li>构造函数能抛出异常
  <li>析构函数理论上能抛出异常，但是最好不要这么做，因为会造成安全问题，如果一定要抛出异常，需要在析构函数内进行catch捕捉，也就是自己内部处理了。
  </details>
<details><summary>8.指针的大小</summary>
  <li>不论指向的类型是什么，在32位操作系统中，指针的大小是4个字节；在64位操作系统中是8个字节。不过即使在64位计算机内编程的时候，指针大小是4是8还是由编译器是64位还是32位决定，前者8，后者4。
    </details>
<details><summary>9.堆和栈的区别</summary>
  <li>1.分配和管理方式不同
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp堆是动态分配的，其空间的分配和释放都由程序员控制。
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由_alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。
  <li>2.产生碎片不同
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp对堆来说，频繁的new/delete或者malloc/free可能会造成内存空间的不连续，造成大量的碎片，使程序效率降低
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出
  <li>3.申请效率不同
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp栈由系统自动分配，速度较快。但程序员是无法控制的
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便
  <li>4.申请大小的限制
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp在Windows下,栈是高地址向低地址扩展的数据结构，是一块连续的内存的区域。 这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp堆：堆是低地址向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。 堆的大小受限于计算机系统中有效的虚拟内存。所以堆获得的空间比较灵活，也比较大。
  <li>5.堆栈缓存方式区别
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。
    <br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
  </details>


<details><summary>10.C++内存管理</summary>

- C++的内存分为六大块:栈区、内存映射段、堆区、全局区（也叫静态区）、常量区、代码区
- 栈区
    - 函数的局部变量的存储单元在栈区上，函数执行结束后栈区会自动释放
    - 栈的空间是由操作系统和编译器自己分配的，栈内存的分配效率高但存储空间有限
- 内存映射段
    - 用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。 
- 堆区
    - 堆区的内存由程序员自己创建并维护，通过malloc和new，但是也要手动释放对应通过free和delete，否则会造成内存泄露
    - 如果在函数内声明一个int型的指针，指向一个用new开辟的空间，那么指针指向的对象的存储空间就是在堆区，而指针本身存储在栈区
- 全局区
    - 全局区也叫静态存储区，存储的是全局变量和用static声明的静态变量
- 常量区
    - 常量区存储程序中的常量
- 代码区
    - 代码区存放函数体的二进制代码
- 当然栈区和堆区的区别不仅仅这些，可以展开去讲  
- 不过关于内存结构还有一种说法就是加入了自由存储区删去了代码区，也就是区分开堆区和自由存储区。不过我不是很认同这种内存布局的看法，因为我认为自由存储去应该是new声明的区域，自由存储区有可能包含在堆区，但也可能不是，所以不好独立开来。
    
</details>

<hr>


<h2>算法题笔记</h2>
<details><summary>
  1.声明一个结构体指针</summary>
<pre>
    (i)node *Begin=(node *)malloc(sizeof(node)),*another=(node *)malloc(sizeof(node));</br>
    (ii)node *Begin=new node(3),*another=new node(5);
</pre>
</details>
<details><summary>2.设计一个二叉树类</summary>
<pre>
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
</pre>
</details>
<hr>
<h2>google代码风格</h2>
<details><summary>函数</summary>
  <li>左大括号总在最后一个参数同一行的末尾处;
  <li>右圆括号和左大括号间总是有一个空格;
  <li>函数首尾不要有空行
</details>
  
<details><summary>其它</summary>
  <li>大括号不另起一行;
  <li>如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用;
  <li>但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用;
  <li>代码块首尾不要有空行
</details>


