<h1>C++编程</h1>
<details><summary>1.什么是<b>段错误</b>?</summary>

- 段错误就是程序访问受保护或者不存在的内存的时候引发的错误
- 引发段错误原因有：访问受保护的内存、访问不存在的内存、访问只读的内存、访问空指针的值、堆栈溢出、内存溢出等
</details>
<details><summary>2.<b>extern</b>关键字有什么用?</summary>

主要有两个作用
- 第一个作用是放在变量名和函数面前，表示声明这个变量或者是函数，而这个变量或者函数是在其它文件中定义的，所以这里只是声明并拿来引用，而非定义，所以也不分配空间
- 第二个作用是和C双引号字符连用，这样让后面的函数在C++程序编译时还是按C编译的规则，就是不改变函数的名字，而如果不加的话，C++编译时会改变函数的名字，通过将函数的名字和参数联合生成一个新的函数名，C++之所以编译会改变函数名字，是为了适用于函数多态服务。而如果在C++文件中使用C语言的头文件，可能因为没有加extern "C"而找不到这个函数。所以extern "C"也常常用于C语言的头文件中。
</details>
<details><summary>3.<b>static</b>关键字有什么用?</summary>

- static用于声明内部连接的变量或函数，和extern相反。
- 首先static可以用在局部变量的声明前，这样的话，这个局部变量将是存储在程序的静态存储区，而非内存栈中。这样一来，这个局部变量的生命周期就会跟整个程序一样，在main函数运行前就会创建，在程序退出时才会销毁。所以当包含局部变量的函数再次调用的时候，这个局部变量依然是上一次退出时的值，也并不会重新创建。
- 第二个是static可以用于全局变量和函数前，这两个作用类似，就是让这个全局变量和函数只能在这个文件内使用，外部文件无法调用。这个通常用在工程项目中防止多个文件内用重名的全局变量和函数，而作用不同发生混淆
- 第三个的话，static可以用在类的成员变量前，这类似于用在局部变量前，这样一来，成员变量存储在静态存储区，然后不依赖与类的对象而存在，也就是创建类的对象时，并不会再分配这个变量空间，因为都是共享这个静态存储区的这个成员变量，这样也能提高速度和优化空间。
- 最后还有，static可以用在成员函数前，这样的话，这个函数没有指向类的this指针，所以也无法访问类的其它成员，除了类内的其它静态成员。所以static并不能修饰类中的构造函数和虚函数，因为两者都需要用到this指针。
- 另外static声明的变量会默认初始化为0
 </details>
<details><summary>4.<b>volatile</b>[ˈvɒlətaɪl]关键字有什么事用？</summary>

- volatile用于声明一个易变的变量，在定义前加volatile，就让这个程序每次使用这个变量的时候都要从内存也就是变量的地址空间中读取变量，而不能到CPU寄存器里读取
- volatile经常用于多线程中，使得一个线程对该变量的改变，等同于能马上让所有其它线程获悉这个改变，保持数据一致性。
</details>
<details><summary>5.<b>const</b>关键字有什么用？(定义 指针 类 define 函数 连接 内存 转换)</summary>

- const关键字用于声明常量，常量就是不发生改变的量，所以const声明变量时需要初始化。
- const可以和指针连用，有两种用法：第一种是常量指针，格式有两种，拿int举例的话是const int* 和 int const*，这两者是等价的,常量指针指的就是这个指针指向的变量是一个常量，但是这个指针指向谁是可以变的，只需要指向的对象是一个常量就行；第二种是指针常量,拿int举例的话就是int *const ,指针常量的意思是这个指针就是一个常量，也就是只能指向初始化给定的地址，不能改变，但是可以通过改变这个地址上存储的数来改变访问该指针时获得的数据。
- const在设计初是用于完美替换#define 宏定义的常量的，这两者的区别就是，一个是用#define定义的常量 不会进行类型安全检查，也没有限定是什么类型，就只是替换；但是const会限定类型，进行安全检查，从安全性上更安全。另一个是存储方式也不同，#define定义的常量不分配空间，但const修饰的常量分配内存空间。然后还有是#define如果定义的常量是一个运算式子，那么每次调用define都会运算一遍，而const会先算出值，之后每次调用就只使用初始化的值。
- const还有在类中用于修饰成员变量和成员函数，修饰成员变量的话，那么这个成员变量就是常量，需要在初始化列表初始化；修饰成员函数的话，其实是修饰这个成员函数的this指针，也是说这个成员函数无法对这个类中的其它变量进行修改，所以const也不能用于类的构造函数，当然也不能用于用static修饰的成员函数，因为static修饰的成员函数没有了this指针。不然如果就是想要在这种情况下成员函数内修改成员变量，可以在那个成员变量前加mutable关键字。然后const用于修饰类的对象的话，那么这个对象只能使用类中用const修饰的成员函数,然后也不能改变这个类的成员变量。
- const还常用语修饰函数的传入参数，那么这个应用是为了保证传入参数在函数期间不会被修改。
- 还有就是在C++中用const修饰的全局变量的连接方式默认为内部连接，就是只有本文件能使用，其它文件不行。不过可以通过在前面再加extern来将连接方式变为外部连接。不过在C中const修饰的全局变量还是外部连接的。
- 另外C和C++中使用const的不同还在于，C++中用const修饰的变量默认是不分配内存空间的，是保存在符号表中的，只用使用到取地址的时候或者前面加extern等操作会再分配内存空间；而C中const修饰的变量一定要分配内存空间。
- 还有一点就是const和非const的转换也是有限制的，非const变量可以给const变量赋值，但反过来不行。对于这点的理解的话，其实类似于数据库中的排它锁和共享锁。const相当于给变量加了共享锁，就是只读数据，而非const就是可读也可写的数据。那么从权限的角度讲，非const给const赋值，取消了可写性，权限降低显然是安全的，但是提高权限则不安全，所以反过来就不行。
</details>
<details><summary>6.<b>new</b>和<b>malloc</b>的区别(来源 位置 调用 类型安全 分配失败 分配大小 构造函数 重载 扩存 内存泄露)</summary>

- new和malloc都是用于给指针分配内存空间的方式。但new是C++的关键字，而malloc是C的库函数方法，通常new和delete配套使用，malloc和free配套使用，防止内存泄露。
- 首先是他们申请的内存空间的所在位置，new申请的内存空间在自由存储区，而malloc申请的内存空间在堆上，两个都是动态分配内存。自由存储区包含堆，自由存储区就是C++根据new申请的内存空间定义的名称，自由存储区具体在哪由operator new函数的实现方式决定，如果是由malloc函数实现的，就是在堆上，其它实现方式的话还可以在静态存储区上，甚至不分配内存。
- 所以这里也提到了new可以调用malloc，就是new可以通过malloc来实现，但是反过来就不行。
- 其次，使用new具有类型安全性，因为new需要指定指针的类型，因为new需要指定具体是哪个类，但malloc没有类型安全性，因为它返回的是一个void*类型的指针，这个指针就是用于强制转换成其它类型的指针，所以malloc通常是使用时进行强制类型转换，所以没有类型安全性。
- 然后关于内存分配失败时的反应也不同，new内存分配失败，也就是内存不够时，会调用一个函数，这个函数是new_handler默认是错误处理函数，它会抛出一个异常，但是用户可以通过set_new_handler函数来设置内存分配失败时做出的处理。但malloc内存分配失败时不会抛出异常，而是返回NULL，继续运行。
- 另外关于分配内存，new在使用时不需要制定分配的内存大小，程序会根据类型自己计算，同时也支持通过中括号[]来进行数组版本的内存分配；但是malloc需要显式地给出分配的内存空间大小，如果是数组的话，就需要乘上数组大小。
- new和malloc还有个关键区别就是，new在使用时会调用这个类的构造函数，之后如果在使用delete回收时delete会调用类的析构函数；而malloc和free不会调用。
- 还有new支持函数重载，但是malloc不支持。
- 不过使用malloc也是有优点的，可以使用配套使用realloc进行扩充内存或者重新分配内存，但是new没有类似的配套方法。
- 之前提到内存泄露，内存泄露对于new和malloc都能检测出来，但是new能具体指出是文件的那一行，但是malloc不行
  </details>
 <details><summary>7.构造、析构函数能抛出异常吗？</summary>

- 构造函数能抛出异常
- 析构函数理论上能抛出异常，但是最好不要这么做，因为会造成安全问题，如果一定要抛出异常，需要在析构函数内进行catch捕捉，也就是自己内部处理了。
  </details>
<details><summary>8.指针的大小</summary>

- 不论指向的类型是什么，在32位操作系统中，指针的大小是4个字节；在64位操作系统中是8个字节。不过即使在64位计算机内编程的时候，指针大小是4是8还是由编译器是64位还是32位决定，前者8，后者4。
    </details>
<details><summary>9.堆和栈的区别</summary>

- 1.分配和管理方式不同
    - 栈是一级缓存，栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由_alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。
    - 堆是二级缓存，堆是动态分配的，其空间的分配和释放都由程序员控制。
- 2.产生碎片不同
    - 对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出
    - 对堆来说，频繁的new/delete或者malloc/free可能会造成内存空间的不连续，造成大量的碎片，使程序效率降低
- 3.申请效率不同
    - 栈由系统自动分配，速度较快。但程序员是无法控制的
    - 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便
- 4.申请大小的限制
    - 在Windows下,栈是高地址向低地址扩展的数据结构，是一块连续的内存的区域。 这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
    - 堆：堆是低地址向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。 堆的大小受限于计算机系统中有效的虚拟内存。所以堆获得的空间比较灵活，也比较大。
  </details>

<details><summary>10.C++内存管理</summary>

- C++的内存分为六大块:栈区、内存映射段、堆区、全局区（也叫静态区）、常量区、代码区
- 栈区
    - 函数的局部变量的存储单元在栈区上，函数执行结束后栈区会自动释放
    - 栈的空间是由操作系统和编译器自己分配的，栈内存的分配效率高但存储空间有限
- 内存映射段
    - 用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。
- 堆区
    - 堆区的内存由程序员自己创建并维护，通过malloc和new，但是也要手动释放对应通过free和delete，否则会造成内存泄露
    - 如果在函数内声明一个int型的指针，指向一个用new开辟的空间，那么指针指向的对象的存储空间就是在堆区，而指针本身存储在栈区
- 全局区
    - 全局区也叫静态存储区，存储的是全局变量和用static声明的静态变量
- 常量区
    - 常量区存储程序中的常量
- 代码区
    - 代码区存放函数体的二进制代码
- 当然栈区和堆区的区别不仅仅这些，可以展开去讲
- 不过关于内存结构还有一种说法就是加入了自由存储区删去了代码区，也就是区分开堆区和自由存储区。不过我不是很认同这种内存布局的看法，因为我认为自由存储去应该是new声明的区域，自由存储区有可能包含在堆区，但也可能不是，所以不好独立开来。
</details>

<details><summary>11.为什么析构函数是虚函数？</summary>

- 首先是析构函数不一定要是虚函数，因为析构函数声明成虚函数需要额外的虚函数表和虚函数指针，需要占用额外的内存，导致浪费内存
- 然后如果当析构函数所在的类是抽象类或者极有可能作为被重写的类的时候，一定设置成虚函数，因为这样才能在用父类指针指向子类对象的时候，释放这个基类指针也能释放子类的空间，防止内存泄露
</details>

<details><summary>12.能展开讲讲智能指针吗？</summary>

- 首先讲讲智能指针是什么:智能指针是用来防止发生内存泄露的一种手段，它是用来管理堆上分配的内存的,它将普通的指针封装为一个类对象指针，也是一个栈对象，当栈对象的生命周期结束后，会在析构函数中释放掉申请的内存，即使程序运行出错也会调用析构函数回收内存，从而防止内存泄露。
- 然后智能指针分为4种auto_ptr、shared_ptr、unique_ptr、weak_ptr
    - auto_ptr，是独占式，也就是保证同一时间只能有一个智能指针占有对象，这个智能指针在C++11中被抛弃了，因为会出现这样的问题，比如用p1 auto_ptr智能指针指向一个对象，然后用p1赋值给另外一个同类型的auto_ptr智能指针p2，这样的话，此时是p2指向这个对象，而p1是空的指针，如果在后续的代码使用了p1可能导致内存崩溃，所以C++11抛弃了auto_ptr
    - unique_ptr,C++11在抛弃了auto_ptr之后就用unique_ptr取代了auto_ptr,同样是独占式的智能指针，但是它不允许赋值，所以之前提到的内存崩溃的问题，在编译阶段就会出错，因为p1不能赋值给p2
    - shared_ptr,是最常用的智能指针,采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配，当新增一个智能指针指向该对象时，引用计数+1，反之-1，当引用计数为0的时候才会释放引用的对象的内存。
        - 对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针
    - weak_ptr,专门用来解决shared_ptr两个智能指针互相引用发生死锁的情况
        - weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。
        - 使用的时候将其中一个shared_ptr转为weak_ptr，这样就能正常释放原来的两个智能指针了。
        - 所以weak_ptr智能指针就是用来指向shared_ptr的。需要注意的是，不能通过weak_ptr去使用对象的方法，如果要使用必须讲weak_ptr转换成shared_ptr;

<details><summary>如何判断weak_ptr的对象是否失效？</summary>

- expired()：检查被引用的对象是否已删除。
- lock():会返回shared指针，判断该指针是否为空。
- use_count():也可以得到shared引用的个数，但速度较慢。
</details>
</details>

<details><summary>13.讲一下vector是怎么实现的</summary>

- vector的底层数据结构非常简单，就是一段连续的线性内存空间，然后采用三个迭代器去完成vector的各种接口操作。
- 这三个迭代器分别是_M_start、_M_finish、_M_end_of_storage
   - _M_start指向的是vector容器的起始字节位置
   - _M_finish指向的是当前最后一个元素的末尾字节位置
   - _M_end_of_storage指向的是整个容器所占用内存空间的末尾字节位置
- 需要专门提出的是vector的扩容操作，就是vector在push_back的时候实际上是让finish当前的值变为当前要push_back的值，再_M_finish迭代器右移，那这里要分两种情况:
   - 一个是finish迭代器的位置在end_of_storage前面，那就是直接右移就行
   - 另一种就是finish迭代器的位置等于end_of_storage迭代器的位置，那这样的话，vector就会调用_M_realloc_insert函数执行扩容操作。
       - 这个时候vector就会将容量乘2，放入最新的元素
       - 当然这个乘2是可以到STL库中去设置的，所以有的版本并不是乘2而是乘1.5，据说这样可以减少内存浪费从而提高效率，但是综合来看乘2是最合理的。
       - 而且这扩容不是在原来的数组基础上扩容的，而是重新申请新的分配空间，然后将原来的数据移动到新的空间中再释放旧的空间，跟Redis map的rehash操作有点像。

</details>

<details><summary>14.讲一下push_back和emplace_back有什么区别？</summary>

- 首先两者都是往vector中添加元素
- push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再调用拷贝构造函数将这个元素拷贝到容器中,再销毁之前创建的这个元素；
- emplace_back() 在实现时，则是调用move函数采用右值引用的方式实现转移语义，直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程，效率更高。
</details>

15.C++11的特性
<details><summary>①类型推导</summary>

- C++11引入了auto和decltype这两个关键字，用于在编译器就推导出变量或者表达式的类型
    - auto用于推导变量的类型
    - decltype用于推导传入的表达式的类型
</details>
<details><summary>②右值引用</summary>

- 首先先说下左值和右值
    - 左值是存储在计算机内存中的一个对象，通常就是赋值符号=号的左边的变量，是可寻址的，可读也可写的、非临时的一个变量
    - 右值仅仅是数据值，是只能读不能写的，通常就是赋值符号=号右边的变量，不能取地址、没有名字同时也是临时的一个值
- 再讲讲左值引用和右值引用
    - 在一个类型后面加一个&符号的声明对象就是左值引用，在C++11之前就只有左值引用，左值引用分常量左值引用和非常量左值引用：
        - 能指向左值，不能指向右值的就是非常量左值引用
        - 能指向右值是常量左值引用，就是在类型前面加个const关键字
    - 在C++11之后才有右值引用，右值引用就是在类型后面加两个&符号
        - 直接传参的话右值引用只能指向右值，不能指向左值
        - 如果要让右值引用指向左值的话需要通过move函数：move函数的唯一功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换。
        - 使用右值引用的目的就是来实现转移语义和精确传递
            - 转移语义就是将资源的所有权从一个对象转移到另一个对象，注意这里是转移而不是拷贝，这样就能减少对象的创建和销毁，从而提高程序效率。类似于从文件复制变成了文件剪切。要实现转移语义需要通过转移构造函数或者转移拷贝操作符，这样对于右值的拷贝和赋值就会调用转移构造函数或者转移拷贝操作符实现转移语义。
            - 精确传递的话也叫完美转发，是指将一组参数原封不动地传递给另一个函数，通过forward函数，forward函数也是和move函数一样是类型转换函数，但是forward函数不仅能转换出右值也能转出左值。参数除了本身的值以外还有两个属性，一个是左右值属性，另一个是是否为常量属性，精确传递就是保证这两个属性和参数值都不变地传递给另一个函数。
- 转移构造函数和转移拷贝操作符实例:
<pre>
转移构造函数:
MyString(MyString&& str) {
    std::cout << "Move Constructor is called! source: " << str._data << std::endl;
     _len = str._len;
    _data = str._data;
    str._len = 0;
    str._data = NULL;
}
</pre>
<pre>
转移拷贝操作符
MyString& operator=(MyString&& str) {
    std::cout << "Move Assignment is called! source: " << str._data << std::endl;
    if (this != &str) {
        _len = str._len;
        _data = str._data;
        str._len = 0;
        str._data = NULL;
    }
    return *this;
}
</pre>
</details>

<details><summary>③列表初始化</summary>

- 可以在变量后面加上初始化列表来进行对对象的初始化
- 可以进行列表初始化的对象是C++内置的类型或者自定义的聚合类
- 一个自定义类是聚合类需要满足:
    - 没有用户声明的构造函数
    - 没有private关键字保护的非静态数据成员
    - 本身不是派生类
    - 内部没有虚函数
    - 内部没有用=号或者使用列表进行初始化的成员
    - 没有默认初始化器
- 列表初始化的长度是任意的，因为它采用了STL中的std::initializer_list类型作为内部实现
</details>
<details><summary>④std::function、std::bind、lambda表达式</summary>

- c++11新增了std::function、std::bind、lambda表达式等封装使函数调用更加方便。
- function是多态函数包装器，function的实例可以存储、复制和调用任何可调用的对象，通常用function结合给定的模板参数来声明一个函数，这个函数可以视为某种函数功能的实现的别名，所以function的实例如果没有给它一个具体的可调用对象，那么就会抛出bad_function_call异常
- bind是绑定器，将可调用对象和参数一起绑定为函数对象，这样在函数传参的时候可以通过bind绑定的函数对象来简化传参或者固定传参，使用bind如果绑定了多个参数，那么使用了bind的这个函数的参数是少于原先这个函数所需要的参数的，因为bind绑定的函数对象此时等同于多个参数
- lambda表达式就是定义一个匿名函数，捕获一定范围内的变量在函数内使用，就地实现函数的功能
    - lambda的语法语法形式:auto func = [capture] (params) opt -> ret { func_body; };
    - 举例
        - auto func1 = [](int a) -> int { return a + 1; };
        - auto func2 = [](int a) { return a + 2; };
        - auto f3 = [=]() mutable { return a++; };
    - lambda通过[]来捕获一定范围内的变量：
        - []不捕获任何变量
        - [&]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用
        - [=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用
        - [=, &a]值捕获外部作用域所有变量，按引用捕获a变量
        - [a]只值捕获a变量，不捕获其它变量
        - [this]捕获当前类中的this指针
    - 常用就是使用lambda表达式自定义stl的规则，例如自定义sort排序规则：
    - struct A {int a;int b;};int main() {   vector<A> vec;   std::sort(vec.begin(), vec.end(), [](const A &left, const A &right) { return left.a < right.a; });}

</details>
<details><summary>⑤对模板的改进</summary>

- C++11模板允许两右尖括号连续出现，在C++11之前，两个连续的尖括号连续出现会被视为右移操作，如果要表示成两个尖括号嵌套必须要在两个尖括号中间加空格。
- C++11引入了using，能更轻松地定义别名。
- C++11之前只有类模板支持默认模板参数，函数模板是不支持默认模板参数的，C++11后都支持。
</details>
<details><summary>⑥其它小的变化</summary>

- 基于范围的for循环，eg:for(int i:V){cout<<i<<endl;}
- 引入委托构造函数，委托构造函数允许在同一个类中，一个构造函数调用另一个构造函数
- 引入继承构造函数，继承构造函数允许派生类直接使用基类的构造函数
- nullptr在C++11中用来表示空指针指向的值，在C++11中表示空指针语义最好使用nullptr而不是NULL，因为NULL本质是一个int型的0，不是空指针的值
</details>
<details><summary>⑦final 和 override</summary>

- final关键字用于修饰一个类，表示这个类不能再进一步派生出子类，也不能再进一步进行虚函数重写
- override用于修饰派生类中的成员函数，表示该函数重写了基类中的同名虚函数，如果派生类中没有对应的虚函数，就会报错。所以使用override就可以保证所写的函数在基类中是存在的，否则编译不通过
</details>
<details><summary>⑧</summary>

-
</details>

<details><summary>15.C++涉及存储位置的关键字</summary>

- auto:分配在栈上
- Register：存储在CPU寄存器上
- static：静态存储区
- extern：外部编译单元（文件）中
</details>

<details><summary>16.Register关键字</summary>

- 用Register关键字声明的变量将尽可能地存放在CPU寄存器中，从而提高访问变量的效率。这里用尽可能是因为CPU的寄存器能存储的变量是有限的
- 所以频繁被使用的变量最好采用register以提高访问速度，否则反而有可能降低程序运行的效率，因为变量并不频繁被使用导致使用的消耗还小于变量被装入cpu寄存器带来的开销
- 但是用register关键字声明的变量必须是能被cpu所接受的类型，比如浮点数或者longlong长整型可能无法被寄存器存放
- 如果用&取地址符号对register声明的变量操作的话，会导致这个register关键字无效，因为这样一来需要知道变量的地址，那么就不能存储在CPU寄存器中
</details>
<hr>


<h2>数据结构与算法</h2>
<details><summary>
  1.声明一个结构体指针</summary>

<pre>
    (i)node *Begin=(node *)malloc(sizeof(node)),*another=(node *)malloc(sizeof(node));</br>
    (ii)node *Begin=new node(3),*another=new node(5);
</pre>
</details>
<details><summary>2.设计一个二叉树类</summary>

<pre>
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
</pre>
</details>
<details><summary>3.STL sort的内部实现</summary>

- 数据量大时会采用快排，分段递归排序，一旦分段后的数据量小于某个阈值，就会改用插入排序，如果递归层过深还会改用堆排序
- 另外就是sort的采用快排的时候，函数内的筛分枢轴选择是采用median-of-three，就是三点中值法，取头中尾三个值取中值
</details>

<details><summary>4.STL Vector的内部实现</summary>

- vector主要是使用三个迭代器去实现的，迭代器可以理解为指针
- 另外就是sort的采用快排的时候，函数内的筛分枢轴选择是采用median-of-three，就是三点中值法，取头中尾三个值取中值
</details>

---

### google代码风格
<details><summary>函数</summary>

- 左大括号总在最后一个参数同一行的末尾处;
- 右圆括号和左大括号间总是有一个空格;
- 函数首尾不要有空行
</details>

<details><summary>其它</summary>

- 大括号不另起一行;
- 如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用;
- 但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用;
- 代码块首尾不要有空行
</details>


