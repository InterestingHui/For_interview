# Python

- 基础
    - [什么是深拷贝和浅拷贝？](#什么是深拷贝和浅拷贝)
    - [双等于和 is 有什么区别？](#双等于和-is-有什么区别)
    - [python的可变对象、不可变对象、可哈希对象？](#python的可变对象和不可变对象有哪些)
- 高级
    - [什么是 Python 生成器？](#什么是-Python-生成器)
    - [迭代器和生成器的区别？](#迭代器和生成器的区别)
    - [dict的实现原理？](#dict的实现原理)
    - [Python的解释器有几种？](#Python的解释器有几种)
    - [什么是GIL(全局解释器锁)？](#什么是GIL)
    - [Python如何实现多核CPU一起使用？](#Python如何实现多核CPU一起使用)
    - [什么是装饰器？](#什么是装饰器)
    - [Python中的垃圾回收机制？](#Python中的垃圾回收机制)
    - [Python 如何进行内存管理？](#Python-如何进行内存管理)
    - [什么是 lambda 表达式？](#什么是-lambda-表达式)

------
### python的可变对象和不可变对象有哪些
- 可变对象：列表、字典、集合
- 不可变对象：数字（包括布尔值）、字符串、元组
- 可哈希对象就是不可变对象

### 什么是 Python 生成器？
- python生成器的定义：一边循环一边计算的机制，是一种迭代器对象
- 生成器有两种形式
    - 使用了yield的函数，叫生成器函数，每次调用都会记录这一次运行到哪，下次调用从上一次调用的位置开始运行
    - 通过括号和列表推导式生成的生成器，叫生成器表达式
- 生成器的作用
    - 节约内存，有些场景不需要一下子存储所有的内存空间，而只是在需要的时候使用特定的几个值，那么就可以用生成器迭代到那然后去使用，或者一边迭代一边使用，这样就不需要存储所有的数，极大地节省了空间
    - 提高性能，由于不需要把所有的数都事先计算出来并存储，所以就不需要额外的开销去做这些事，所以时间、性能上也提升了
- 代码
```python
# 生成器函数
def f():
    for i in range(5):
        yield 2*i-1

# 生成器表达式
g = (i for i in range(3))

# 通过__next__()来访问并迭代生成器
# 需要注意的是，生成器函数的持续迭代需要事先通过一个变量赋值为这个生成器函数，对这个变量去迭代，才是对这个生成器函数的正确使用
print(f().__next(), g.__next__())# 打印-1，0

# 如果超过了能迭代的上限会引起StopIteration异常，可以通过这个特殊的异常来进行try异常处理
```

### 迭代器和生成器的区别？
- 生成器是一种数据结构，而迭代器是一种访问集合的方式
- 但是从使用上来说，生成器和迭代器可以说是相同的，都是通过__next__()来访问下一个

### dict的实现原理
- dict底层是通过一个哈希表叫enteies和一个列表叫indices实现的
- 这里的哈希表是逻辑上的，实际上也是一个列表，里面的元素是一个个含有三个元素的列表，这三个元素就分别代表index、key、value，这个index就是在indices列表中存储的索引
- 通过这两个数据结构实现了字典的有序且达到访问的平均复杂度是O(1)
- 列表不能作为dict的key，因为是不可哈希的

### Python的解释器有几种
- CPython：C语言开发，使用最广，默认的解释器
- IPython：基于CPython之上的交互式解释器
- PyPy：采用JIT技术，对python代码进行动态编译，追求执行速度
- Jython：运行在Java平台上的解释器，可以直接编译成Java字节码执行
- IronPython：同理Jython，运行在 .Net 平台上

### 什么是GIL
- GIL全局解释器锁 是Python的解释器用于同步线程的一种机制
- 它使得任何时刻仅有一个线程在执行，因为每个线程再执行前都需要先获取GIL才能执行
- 即便在多核处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程，常见的使用 GIL 的解释器有CPython与Ruby MRI。可以看到GIL并不是Python独有的特性，是解释型语言处理多线程问题的一种机制而非语言特性。
- 这也是一般Python不能实现多线程并发，也就是说不能多核CPU并发的原因

### Python如何实现多核CPU一起使用？
- 首先一般Python由于GIL全局解释器锁的存在无法实现多线程并发也就是多线程使用多核CPU的情况
- 但是可以通过多进程实现多核任务，采用multiprocessing这个多进程标准库。
- 也可以通过将关键部分通过扩展来采用C/C++实现，然后让C/C++使用多核CPU并发再集成到Python代码中，这种方式也能达到多核CPU并发
- 或者还有一种方式就是采用不使用GIL的解释器例如Jython

<details><summary>什么时候线程会释放GIL？</summary>

- 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL
- Python 3.x使用计时器,执行时间达到阈值后，当前线程会释放GIL
</details>

### 什么是装饰器？
- Python装饰器本质上是一个函数，它可以让一个函数或者说方法在不需要修改任何代码的基础上增加额外的功能，也就是说装饰器能拓展函数的功能
- 装饰器也有返回值，返回的就是这个函数的指针，使用装饰器的地方就相当于给这个函数外面再套了一个函数，做了一些事情，然后返回被修饰的函数
- 使用的方式就是采用'@'符语法糖，就在函数或者方法的上方采用相同缩进再加相应的装饰器名称就行了
- 可以为函数装饰多个装饰器，装饰器的调用顺序就是和语法糖的顺序相反也就是从下往上装饰的

### Python中的垃圾回收机制？
- Python的垃圾回收机制是以引用计数为主，标记-清除和分代收集两种机制为辅的策略
- 引用计数机制
    - Python中每个东西都是一个Pyobject结构体对象
    - 这个结构体内有个ob_refcnt属性，作用就是引用计数
        - 当这个对象有新的引用时，这个属性就会+1，反之被删除就会-1
        - 当这个属性为0的时候，这个对象的生命周期就结束了，内存释放
    - 好处在于简单和实时性，一旦没有引用，内存就会直接释放了
    - 坏处在于维护引用计数会消耗资源而且可能会出现循环引用的情况,eg:
```python
list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
```
- 标记-清除机制
    - 是为了解决容器对象可能产生的循环引用的问题
    - 分为两步：
        - 第一步：标记阶段，遍历所有的对象，如果对象可达，即有对象引用它，就将该对象标记
        - 第二步：清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，就将其回收
        - 类似于有向图拓扑序去点的过程
    - 在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。
    - 例如python解释器(Cpython)会维护两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象
    - 在执行这个垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行
- 分代回收机制
    - 为了提高当使用标记-清除机制去回收循环引用的时候的效率问题
    - 因为在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过“分代回收”(Generational Collection)以空间换时间的方法提高垃圾回收效率
    - 分代回收简单描述对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。
        - python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。
        - gc的扫描的触发条件就是当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候
            - 当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。
        - 通过上述方法就能完成分代回收提高回收效能


### 什么是 lambda 表达式？
- lambda表达式是一个匿名函数，也就是不需要给定函数名，用于快速定义简单功能的单行函数
- 一般用来实现单一、简单的函数功能，方便快捷并且不需要再花心思去思考函数名
- lambda表达式一般的形式是：关键词lambda后面紧接一个或多个参数，紧接一个冒号“：”，紧接一个表达式
    - eg:sum = lambda a,b : a+b

### 赋值、浅拷贝和深拷贝的区别？
- 赋值（=）
    - 就是创建了对象的一个新的引用，修改其中任意一个变量都会相同地影响到另一个，因为两个是指向同一个对象的。
- 浅拷贝copy.copy()或者对象调用.copy()方法：
    - 拷贝并创建一个新的父对象，但对于拷贝对象的内部的子对象创建的仅是引用，也就是说内部的子对象是指向相同元素的
    - 所以对于一个列表的浅拷贝，如果对原列表append一个元素，拷贝对象不会有任何变化
    - 但是如果这个原列表内的元素有列表，对这个元素列表append一个数，拷贝对象内的元素列表也会append一个数，因为子对象指向的是相同的对象，拷贝的只是引用
- 深拷贝copy模块的deepcopy方法：
    - 创建一个新的对象，并且递归的复制它所包含的对象
    - 也就是说新的对象完全独立于原对象，改变原对象的任何东西都不会对新对象造成影响

### 双等于和 is 有什么区别？
```==```比较的是两个变量的 value，只要值相等就会返回True
```is```比较的是两个变量的 id，即```id(a) == id(b)```，只有两个变量指向同一个对象的时候，才会返回True
但是对于小数据，Python有缓存机制，所以使用is在判断两数相等时很可能会因为指向相同的缓存数据而返回True
eg:
```python
a,b=1000000000000000*3300000000000000000000000,1000000000000000*3300000000000000000000000
A,B=11,11
print(a is b,A is B)# False, True
```
